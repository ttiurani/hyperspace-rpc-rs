// This file is generated by rust-protobuf 2.18.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `schema.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_0;

#[derive(PartialEq,Clone,Default)]
pub struct Peer {
    // message fields
    remotePublicKey: ::std::option::Option<::bytes::Bytes>,
    remoteAddress: ::std::option::Option<::protobuf::Chars>,
    field_type: ::std::option::Option<::protobuf::Chars>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Peer {
    fn default() -> &'a Peer {
        <Peer as ::protobuf::Message>::default_instance()
    }
}

impl Peer {
    pub fn new() -> Peer {
        ::std::default::Default::default()
    }

    // required bytes remotePublicKey = 1;


    pub fn get_remotePublicKey(&self) -> &[u8] {
        match self.remotePublicKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
    pub fn clear_remotePublicKey(&mut self) {
        self.remotePublicKey = ::std::option::Option::None;
    }

    pub fn has_remotePublicKey(&self) -> bool {
        self.remotePublicKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remotePublicKey(&mut self, v: ::bytes::Bytes) {
        self.remotePublicKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remotePublicKey(&mut self) -> &mut ::bytes::Bytes {
        if self.remotePublicKey.is_none() {
            self.remotePublicKey = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.remotePublicKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_remotePublicKey(&mut self) -> ::bytes::Bytes {
        self.remotePublicKey.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // required string remoteAddress = 2;


    pub fn get_remoteAddress(&self) -> &str {
        match self.remoteAddress.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_remoteAddress(&mut self) {
        self.remoteAddress = ::std::option::Option::None;
    }

    pub fn has_remoteAddress(&self) -> bool {
        self.remoteAddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remoteAddress(&mut self, v: ::protobuf::Chars) {
        self.remoteAddress = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remoteAddress(&mut self) -> &mut ::protobuf::Chars {
        if self.remoteAddress.is_none() {
            self.remoteAddress = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.remoteAddress.as_mut().unwrap()
    }

    // Take field
    pub fn take_remoteAddress(&mut self) -> ::protobuf::Chars {
        self.remoteAddress.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // required string type = 3;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::protobuf::Chars) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::protobuf::Chars {
        if self.field_type.is_none() {
            self.field_type = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::protobuf::Chars {
        self.field_type.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for Peer {
    fn is_initialized(&self) -> bool {
        if self.remotePublicKey.is_none() {
            return false;
        }
        if self.remoteAddress.is_none() {
            return false;
        }
        if self.field_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_carllerche_bytes_into(wire_type, is, &mut self.remotePublicKey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.remoteAddress)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.field_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.remotePublicKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.remoteAddress.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.remotePublicKey.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(ref v) = self.remoteAddress.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Peer {
        Peer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "remotePublicKey",
                |m: &Peer| { &m.remotePublicKey },
                |m: &mut Peer| { &mut m.remotePublicKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                "remoteAddress",
                |m: &Peer| { &m.remoteAddress },
                |m: &mut Peer| { &mut m.remoteAddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                "type",
                |m: &Peer| { &m.field_type },
                |m: &mut Peer| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Peer>(
                "Peer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Peer {
        static instance: ::protobuf::rt::LazyV2<Peer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Peer::new)
    }
}

impl ::protobuf::Clear for Peer {
    fn clear(&mut self) {
        self.remotePublicKey = ::std::option::Option::None;
        self.remoteAddress = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Peer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Peer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HyperspaceStatusResponse {
    // message fields
    apiVersion: ::std::option::Option<::protobuf::Chars>,
    holepunchable: ::std::option::Option<bool>,
    remoteAddress: ::std::option::Option<::protobuf::Chars>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HyperspaceStatusResponse {
    fn default() -> &'a HyperspaceStatusResponse {
        <HyperspaceStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl HyperspaceStatusResponse {
    pub fn new() -> HyperspaceStatusResponse {
        ::std::default::Default::default()
    }

    // required string apiVersion = 1;


    pub fn get_apiVersion(&self) -> &str {
        match self.apiVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_apiVersion(&mut self) {
        self.apiVersion = ::std::option::Option::None;
    }

    pub fn has_apiVersion(&self) -> bool {
        self.apiVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiVersion(&mut self, v: ::protobuf::Chars) {
        self.apiVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiVersion(&mut self) -> &mut ::protobuf::Chars {
        if self.apiVersion.is_none() {
            self.apiVersion = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.apiVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiVersion(&mut self) -> ::protobuf::Chars {
        self.apiVersion.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional bool holepunchable = 2;


    pub fn get_holepunchable(&self) -> bool {
        self.holepunchable.unwrap_or(false)
    }
    pub fn clear_holepunchable(&mut self) {
        self.holepunchable = ::std::option::Option::None;
    }

    pub fn has_holepunchable(&self) -> bool {
        self.holepunchable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_holepunchable(&mut self, v: bool) {
        self.holepunchable = ::std::option::Option::Some(v);
    }

    // optional string remoteAddress = 3;


    pub fn get_remoteAddress(&self) -> &str {
        match self.remoteAddress.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_remoteAddress(&mut self) {
        self.remoteAddress = ::std::option::Option::None;
    }

    pub fn has_remoteAddress(&self) -> bool {
        self.remoteAddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remoteAddress(&mut self, v: ::protobuf::Chars) {
        self.remoteAddress = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remoteAddress(&mut self) -> &mut ::protobuf::Chars {
        if self.remoteAddress.is_none() {
            self.remoteAddress = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.remoteAddress.as_mut().unwrap()
    }

    // Take field
    pub fn take_remoteAddress(&mut self) -> ::protobuf::Chars {
        self.remoteAddress.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for HyperspaceStatusResponse {
    fn is_initialized(&self) -> bool {
        if self.apiVersion.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.apiVersion)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.holepunchable = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.remoteAddress)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.apiVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.holepunchable {
            my_size += 2;
        }
        if let Some(ref v) = self.remoteAddress.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.apiVersion.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.holepunchable {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.remoteAddress.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HyperspaceStatusResponse {
        HyperspaceStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                "apiVersion",
                |m: &HyperspaceStatusResponse| { &m.apiVersion },
                |m: &mut HyperspaceStatusResponse| { &mut m.apiVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "holepunchable",
                |m: &HyperspaceStatusResponse| { &m.holepunchable },
                |m: &mut HyperspaceStatusResponse| { &mut m.holepunchable },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                "remoteAddress",
                |m: &HyperspaceStatusResponse| { &m.remoteAddress },
                |m: &mut HyperspaceStatusResponse| { &mut m.remoteAddress },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HyperspaceStatusResponse>(
                "HyperspaceStatusResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HyperspaceStatusResponse {
        static instance: ::protobuf::rt::LazyV2<HyperspaceStatusResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HyperspaceStatusResponse::new)
    }
}

impl ::protobuf::Clear for HyperspaceStatusResponse {
    fn clear(&mut self) {
        self.apiVersion = ::std::option::Option::None;
        self.holepunchable = ::std::option::Option::None;
        self.remoteAddress = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HyperspaceStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HyperspaceStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpenRequest {
    // message fields
    id: ::std::option::Option<u32>,
    key: ::std::option::Option<::bytes::Bytes>,
    name: ::std::option::Option<::protobuf::Chars>,
    weak: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpenRequest {
    fn default() -> &'a OpenRequest {
        <OpenRequest as ::protobuf::Message>::default_instance()
    }
}

impl OpenRequest {
    pub fn new() -> OpenRequest {
        ::std::default::Default::default()
    }

    // required uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional bytes key = 2;


    pub fn get_key(&self) -> &[u8] {
        match self.key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::bytes::Bytes) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::bytes::Bytes {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::bytes::Bytes {
        self.key.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::protobuf::Chars) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::protobuf::Chars {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::protobuf::Chars {
        self.name.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional bool weak = 4;


    pub fn get_weak(&self) -> bool {
        self.weak.unwrap_or(false)
    }
    pub fn clear_weak(&mut self) {
        self.weak = ::std::option::Option::None;
    }

    pub fn has_weak(&self) -> bool {
        self.weak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weak(&mut self, v: bool) {
        self.weak = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for OpenRequest {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_carllerche_bytes_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.weak = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.weak {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.weak {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpenRequest {
        OpenRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &OpenRequest| { &m.id },
                |m: &mut OpenRequest| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "key",
                |m: &OpenRequest| { &m.key },
                |m: &mut OpenRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                "name",
                |m: &OpenRequest| { &m.name },
                |m: &mut OpenRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "weak",
                |m: &OpenRequest| { &m.weak },
                |m: &mut OpenRequest| { &mut m.weak },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpenRequest>(
                "OpenRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpenRequest {
        static instance: ::protobuf::rt::LazyV2<OpenRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpenRequest::new)
    }
}

impl ::protobuf::Clear for OpenRequest {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.key = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.weak = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpenRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpenRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpenResponse {
    // message fields
    key: ::std::option::Option<::bytes::Bytes>,
    length: ::std::option::Option<u64>,
    byteLength: ::std::option::Option<u64>,
    writable: ::std::option::Option<bool>,
    pub peers: ::protobuf::RepeatedField<Peer>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpenResponse {
    fn default() -> &'a OpenResponse {
        <OpenResponse as ::protobuf::Message>::default_instance()
    }
}

impl OpenResponse {
    pub fn new() -> OpenResponse {
        ::std::default::Default::default()
    }

    // required bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        match self.key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::bytes::Bytes) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::bytes::Bytes {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::bytes::Bytes {
        self.key.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // required uint64 length = 2;


    pub fn get_length(&self) -> u64 {
        self.length.unwrap_or(0)
    }
    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = ::std::option::Option::Some(v);
    }

    // required uint64 byteLength = 3;


    pub fn get_byteLength(&self) -> u64 {
        self.byteLength.unwrap_or(0)
    }
    pub fn clear_byteLength(&mut self) {
        self.byteLength = ::std::option::Option::None;
    }

    pub fn has_byteLength(&self) -> bool {
        self.byteLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_byteLength(&mut self, v: u64) {
        self.byteLength = ::std::option::Option::Some(v);
    }

    // required bool writable = 4;


    pub fn get_writable(&self) -> bool {
        self.writable.unwrap_or(false)
    }
    pub fn clear_writable(&mut self) {
        self.writable = ::std::option::Option::None;
    }

    pub fn has_writable(&self) -> bool {
        self.writable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_writable(&mut self, v: bool) {
        self.writable = ::std::option::Option::Some(v);
    }

    // repeated .hyperspace.Peer peers = 5;


    pub fn get_peers(&self) -> &[Peer] {
        &self.peers
    }
    pub fn clear_peers(&mut self) {
        self.peers.clear();
    }

    // Param is passed by value, moved
    pub fn set_peers(&mut self, v: ::protobuf::RepeatedField<Peer>) {
        self.peers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peers(&mut self) -> &mut ::protobuf::RepeatedField<Peer> {
        &mut self.peers
    }

    // Take field
    pub fn take_peers(&mut self) -> ::protobuf::RepeatedField<Peer> {
        ::std::mem::replace(&mut self.peers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OpenResponse {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.length.is_none() {
            return false;
        }
        if self.byteLength.is_none() {
            return false;
        }
        if self.writable.is_none() {
            return false;
        }
        for v in &self.peers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_carllerche_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.byteLength = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.writable = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.peers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.byteLength {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.writable {
            my_size += 2;
        }
        for value in &self.peers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.length {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.byteLength {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.writable {
            os.write_bool(4, v)?;
        }
        for v in &self.peers {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpenResponse {
        OpenResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "key",
                |m: &OpenResponse| { &m.key },
                |m: &mut OpenResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "length",
                |m: &OpenResponse| { &m.length },
                |m: &mut OpenResponse| { &mut m.length },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "byteLength",
                |m: &OpenResponse| { &m.byteLength },
                |m: &mut OpenResponse| { &mut m.byteLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "writable",
                |m: &OpenResponse| { &m.writable },
                |m: &mut OpenResponse| { &mut m.writable },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Peer>>(
                "peers",
                |m: &OpenResponse| { &m.peers },
                |m: &mut OpenResponse| { &mut m.peers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpenResponse>(
                "OpenResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpenResponse {
        static instance: ::protobuf::rt::LazyV2<OpenResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpenResponse::new)
    }
}

impl ::protobuf::Clear for OpenResponse {
    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.length = ::std::option::Option::None;
        self.byteLength = ::std::option::Option::None;
        self.writable = ::std::option::Option::None;
        self.peers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpenResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpenResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeedEvent {
    // message fields
    key: ::std::option::Option<::bytes::Bytes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeedEvent {
    fn default() -> &'a FeedEvent {
        <FeedEvent as ::protobuf::Message>::default_instance()
    }
}

impl FeedEvent {
    pub fn new() -> FeedEvent {
        ::std::default::Default::default()
    }

    // required bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        match self.key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::bytes::Bytes) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::bytes::Bytes {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::bytes::Bytes {
        self.key.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }
}

impl ::protobuf::Message for FeedEvent {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_carllerche_bytes_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeedEvent {
        FeedEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "key",
                |m: &FeedEvent| { &m.key },
                |m: &mut FeedEvent| { &mut m.key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeedEvent>(
                "FeedEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeedEvent {
        static instance: ::protobuf::rt::LazyV2<FeedEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeedEvent::new)
    }
}

impl ::protobuf::Clear for FeedEvent {
    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeedEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeedEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpenNetworkResponse {
    // message fields
    publicKey: ::std::option::Option<::bytes::Bytes>,
    pub peers: ::protobuf::RepeatedField<Peer>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpenNetworkResponse {
    fn default() -> &'a OpenNetworkResponse {
        <OpenNetworkResponse as ::protobuf::Message>::default_instance()
    }
}

impl OpenNetworkResponse {
    pub fn new() -> OpenNetworkResponse {
        ::std::default::Default::default()
    }

    // required bytes publicKey = 1;


    pub fn get_publicKey(&self) -> &[u8] {
        match self.publicKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
    pub fn clear_publicKey(&mut self) {
        self.publicKey = ::std::option::Option::None;
    }

    pub fn has_publicKey(&self) -> bool {
        self.publicKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publicKey(&mut self, v: ::bytes::Bytes) {
        self.publicKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_publicKey(&mut self) -> &mut ::bytes::Bytes {
        if self.publicKey.is_none() {
            self.publicKey = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.publicKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_publicKey(&mut self) -> ::bytes::Bytes {
        self.publicKey.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // repeated .hyperspace.Peer peers = 2;


    pub fn get_peers(&self) -> &[Peer] {
        &self.peers
    }
    pub fn clear_peers(&mut self) {
        self.peers.clear();
    }

    // Param is passed by value, moved
    pub fn set_peers(&mut self, v: ::protobuf::RepeatedField<Peer>) {
        self.peers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peers(&mut self) -> &mut ::protobuf::RepeatedField<Peer> {
        &mut self.peers
    }

    // Take field
    pub fn take_peers(&mut self) -> ::protobuf::RepeatedField<Peer> {
        ::std::mem::replace(&mut self.peers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OpenNetworkResponse {
    fn is_initialized(&self) -> bool {
        if self.publicKey.is_none() {
            return false;
        }
        for v in &self.peers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_carllerche_bytes_into(wire_type, is, &mut self.publicKey)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.peers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.publicKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        for value in &self.peers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.publicKey.as_ref() {
            os.write_bytes(1, v)?;
        }
        for v in &self.peers {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpenNetworkResponse {
        OpenNetworkResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "publicKey",
                |m: &OpenNetworkResponse| { &m.publicKey },
                |m: &mut OpenNetworkResponse| { &mut m.publicKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Peer>>(
                "peers",
                |m: &OpenNetworkResponse| { &m.peers },
                |m: &mut OpenNetworkResponse| { &mut m.peers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpenNetworkResponse>(
                "OpenNetworkResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpenNetworkResponse {
        static instance: ::protobuf::rt::LazyV2<OpenNetworkResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpenNetworkResponse::new)
    }
}

impl ::protobuf::Clear for OpenNetworkResponse {
    fn clear(&mut self) {
        self.publicKey = ::std::option::Option::None;
        self.peers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpenNetworkResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpenNetworkResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NetworkStatus {
    // message fields
    discoveryKey: ::std::option::Option<::bytes::Bytes>,
    announce: ::std::option::Option<bool>,
    lookup: ::std::option::Option<bool>,
    remember: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NetworkStatus {
    fn default() -> &'a NetworkStatus {
        <NetworkStatus as ::protobuf::Message>::default_instance()
    }
}

impl NetworkStatus {
    pub fn new() -> NetworkStatus {
        ::std::default::Default::default()
    }

    // required bytes discoveryKey = 1;


    pub fn get_discoveryKey(&self) -> &[u8] {
        match self.discoveryKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
    pub fn clear_discoveryKey(&mut self) {
        self.discoveryKey = ::std::option::Option::None;
    }

    pub fn has_discoveryKey(&self) -> bool {
        self.discoveryKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_discoveryKey(&mut self, v: ::bytes::Bytes) {
        self.discoveryKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_discoveryKey(&mut self) -> &mut ::bytes::Bytes {
        if self.discoveryKey.is_none() {
            self.discoveryKey = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.discoveryKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_discoveryKey(&mut self) -> ::bytes::Bytes {
        self.discoveryKey.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bool announce = 2;


    pub fn get_announce(&self) -> bool {
        self.announce.unwrap_or(false)
    }
    pub fn clear_announce(&mut self) {
        self.announce = ::std::option::Option::None;
    }

    pub fn has_announce(&self) -> bool {
        self.announce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announce(&mut self, v: bool) {
        self.announce = ::std::option::Option::Some(v);
    }

    // optional bool lookup = 3;


    pub fn get_lookup(&self) -> bool {
        self.lookup.unwrap_or(false)
    }
    pub fn clear_lookup(&mut self) {
        self.lookup = ::std::option::Option::None;
    }

    pub fn has_lookup(&self) -> bool {
        self.lookup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lookup(&mut self, v: bool) {
        self.lookup = ::std::option::Option::Some(v);
    }

    // optional bool remember = 4;


    pub fn get_remember(&self) -> bool {
        self.remember.unwrap_or(false)
    }
    pub fn clear_remember(&mut self) {
        self.remember = ::std::option::Option::None;
    }

    pub fn has_remember(&self) -> bool {
        self.remember.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remember(&mut self, v: bool) {
        self.remember = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for NetworkStatus {
    fn is_initialized(&self) -> bool {
        if self.discoveryKey.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_carllerche_bytes_into(wire_type, is, &mut self.discoveryKey)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.announce = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.lookup = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.remember = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.discoveryKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.announce {
            my_size += 2;
        }
        if let Some(v) = self.lookup {
            my_size += 2;
        }
        if let Some(v) = self.remember {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.discoveryKey.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.announce {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.lookup {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.remember {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NetworkStatus {
        NetworkStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "discoveryKey",
                |m: &NetworkStatus| { &m.discoveryKey },
                |m: &mut NetworkStatus| { &mut m.discoveryKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "announce",
                |m: &NetworkStatus| { &m.announce },
                |m: &mut NetworkStatus| { &mut m.announce },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "lookup",
                |m: &NetworkStatus| { &m.lookup },
                |m: &mut NetworkStatus| { &mut m.lookup },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "remember",
                |m: &NetworkStatus| { &m.remember },
                |m: &mut NetworkStatus| { &mut m.remember },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NetworkStatus>(
                "NetworkStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NetworkStatus {
        static instance: ::protobuf::rt::LazyV2<NetworkStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NetworkStatus::new)
    }
}

impl ::protobuf::Clear for NetworkStatus {
    fn clear(&mut self) {
        self.discoveryKey = ::std::option::Option::None;
        self.announce = ::std::option::Option::None;
        self.lookup = ::std::option::Option::None;
        self.remember = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NetworkStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigureNetworkRequest {
    // message fields
    pub configuration: ::protobuf::SingularPtrField<NetworkStatus>,
    flush: ::std::option::Option<bool>,
    copyFrom: ::std::option::Option<::bytes::Bytes>,
    overwrite: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigureNetworkRequest {
    fn default() -> &'a ConfigureNetworkRequest {
        <ConfigureNetworkRequest as ::protobuf::Message>::default_instance()
    }
}

impl ConfigureNetworkRequest {
    pub fn new() -> ConfigureNetworkRequest {
        ::std::default::Default::default()
    }

    // required .hyperspace.NetworkStatus configuration = 1;


    pub fn get_configuration(&self) -> &NetworkStatus {
        self.configuration.as_ref().unwrap_or_else(|| <NetworkStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_configuration(&mut self) {
        self.configuration.clear();
    }

    pub fn has_configuration(&self) -> bool {
        self.configuration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configuration(&mut self, v: NetworkStatus) {
        self.configuration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configuration(&mut self) -> &mut NetworkStatus {
        if self.configuration.is_none() {
            self.configuration.set_default();
        }
        self.configuration.as_mut().unwrap()
    }

    // Take field
    pub fn take_configuration(&mut self) -> NetworkStatus {
        self.configuration.take().unwrap_or_else(|| NetworkStatus::new())
    }

    // optional bool flush = 2;


    pub fn get_flush(&self) -> bool {
        self.flush.unwrap_or(false)
    }
    pub fn clear_flush(&mut self) {
        self.flush = ::std::option::Option::None;
    }

    pub fn has_flush(&self) -> bool {
        self.flush.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flush(&mut self, v: bool) {
        self.flush = ::std::option::Option::Some(v);
    }

    // optional bytes copyFrom = 3;


    pub fn get_copyFrom(&self) -> &[u8] {
        match self.copyFrom.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
    pub fn clear_copyFrom(&mut self) {
        self.copyFrom = ::std::option::Option::None;
    }

    pub fn has_copyFrom(&self) -> bool {
        self.copyFrom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_copyFrom(&mut self, v: ::bytes::Bytes) {
        self.copyFrom = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_copyFrom(&mut self) -> &mut ::bytes::Bytes {
        if self.copyFrom.is_none() {
            self.copyFrom = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.copyFrom.as_mut().unwrap()
    }

    // Take field
    pub fn take_copyFrom(&mut self) -> ::bytes::Bytes {
        self.copyFrom.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bool overwrite = 4;


    pub fn get_overwrite(&self) -> bool {
        self.overwrite.unwrap_or(true)
    }
    pub fn clear_overwrite(&mut self) {
        self.overwrite = ::std::option::Option::None;
    }

    pub fn has_overwrite(&self) -> bool {
        self.overwrite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overwrite(&mut self, v: bool) {
        self.overwrite = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ConfigureNetworkRequest {
    fn is_initialized(&self) -> bool {
        if self.configuration.is_none() {
            return false;
        }
        for v in &self.configuration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.configuration)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.flush = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_carllerche_bytes_into(wire_type, is, &mut self.copyFrom)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.overwrite = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.configuration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.flush {
            my_size += 2;
        }
        if let Some(ref v) = self.copyFrom.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.overwrite {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.configuration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.flush {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.copyFrom.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.overwrite {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigureNetworkRequest {
        ConfigureNetworkRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NetworkStatus>>(
                "configuration",
                |m: &ConfigureNetworkRequest| { &m.configuration },
                |m: &mut ConfigureNetworkRequest| { &mut m.configuration },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "flush",
                |m: &ConfigureNetworkRequest| { &m.flush },
                |m: &mut ConfigureNetworkRequest| { &mut m.flush },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "copyFrom",
                |m: &ConfigureNetworkRequest| { &m.copyFrom },
                |m: &mut ConfigureNetworkRequest| { &mut m.copyFrom },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "overwrite",
                |m: &ConfigureNetworkRequest| { &m.overwrite },
                |m: &mut ConfigureNetworkRequest| { &mut m.overwrite },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfigureNetworkRequest>(
                "ConfigureNetworkRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfigureNetworkRequest {
        static instance: ::protobuf::rt::LazyV2<ConfigureNetworkRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigureNetworkRequest::new)
    }
}

impl ::protobuf::Clear for ConfigureNetworkRequest {
    fn clear(&mut self) {
        self.configuration.clear();
        self.flush = ::std::option::Option::None;
        self.copyFrom = ::std::option::Option::None;
        self.overwrite = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigureNetworkRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigureNetworkRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NetworkStatusRequest {
    // message fields
    discoveryKey: ::std::option::Option<::bytes::Bytes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NetworkStatusRequest {
    fn default() -> &'a NetworkStatusRequest {
        <NetworkStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl NetworkStatusRequest {
    pub fn new() -> NetworkStatusRequest {
        ::std::default::Default::default()
    }

    // required bytes discoveryKey = 1;


    pub fn get_discoveryKey(&self) -> &[u8] {
        match self.discoveryKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
    pub fn clear_discoveryKey(&mut self) {
        self.discoveryKey = ::std::option::Option::None;
    }

    pub fn has_discoveryKey(&self) -> bool {
        self.discoveryKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_discoveryKey(&mut self, v: ::bytes::Bytes) {
        self.discoveryKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_discoveryKey(&mut self) -> &mut ::bytes::Bytes {
        if self.discoveryKey.is_none() {
            self.discoveryKey = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.discoveryKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_discoveryKey(&mut self) -> ::bytes::Bytes {
        self.discoveryKey.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }
}

impl ::protobuf::Message for NetworkStatusRequest {
    fn is_initialized(&self) -> bool {
        if self.discoveryKey.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_carllerche_bytes_into(wire_type, is, &mut self.discoveryKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.discoveryKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.discoveryKey.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NetworkStatusRequest {
        NetworkStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "discoveryKey",
                |m: &NetworkStatusRequest| { &m.discoveryKey },
                |m: &mut NetworkStatusRequest| { &mut m.discoveryKey },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NetworkStatusRequest>(
                "NetworkStatusRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NetworkStatusRequest {
        static instance: ::protobuf::rt::LazyV2<NetworkStatusRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NetworkStatusRequest::new)
    }
}

impl ::protobuf::Clear for NetworkStatusRequest {
    fn clear(&mut self) {
        self.discoveryKey = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NetworkStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NetworkStatusResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<NetworkStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NetworkStatusResponse {
    fn default() -> &'a NetworkStatusResponse {
        <NetworkStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl NetworkStatusResponse {
    pub fn new() -> NetworkStatusResponse {
        ::std::default::Default::default()
    }

    // optional .hyperspace.NetworkStatus status = 1;


    pub fn get_status(&self) -> &NetworkStatus {
        self.status.as_ref().unwrap_or_else(|| <NetworkStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: NetworkStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut NetworkStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> NetworkStatus {
        self.status.take().unwrap_or_else(|| NetworkStatus::new())
    }
}

impl ::protobuf::Message for NetworkStatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NetworkStatusResponse {
        NetworkStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NetworkStatus>>(
                "status",
                |m: &NetworkStatusResponse| { &m.status },
                |m: &mut NetworkStatusResponse| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NetworkStatusResponse>(
                "NetworkStatusResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NetworkStatusResponse {
        static instance: ::protobuf::rt::LazyV2<NetworkStatusResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NetworkStatusResponse::new)
    }
}

impl ::protobuf::Clear for NetworkStatusResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NetworkStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AllNetworkStatusesResponse {
    // message fields
    pub statuses: ::protobuf::RepeatedField<NetworkStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AllNetworkStatusesResponse {
    fn default() -> &'a AllNetworkStatusesResponse {
        <AllNetworkStatusesResponse as ::protobuf::Message>::default_instance()
    }
}

impl AllNetworkStatusesResponse {
    pub fn new() -> AllNetworkStatusesResponse {
        ::std::default::Default::default()
    }

    // repeated .hyperspace.NetworkStatus statuses = 1;


    pub fn get_statuses(&self) -> &[NetworkStatus] {
        &self.statuses
    }
    pub fn clear_statuses(&mut self) {
        self.statuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_statuses(&mut self, v: ::protobuf::RepeatedField<NetworkStatus>) {
        self.statuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statuses(&mut self) -> &mut ::protobuf::RepeatedField<NetworkStatus> {
        &mut self.statuses
    }

    // Take field
    pub fn take_statuses(&mut self) -> ::protobuf::RepeatedField<NetworkStatus> {
        ::std::mem::replace(&mut self.statuses, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AllNetworkStatusesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.statuses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.statuses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.statuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.statuses {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AllNetworkStatusesResponse {
        AllNetworkStatusesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NetworkStatus>>(
                "statuses",
                |m: &AllNetworkStatusesResponse| { &m.statuses },
                |m: &mut AllNetworkStatusesResponse| { &mut m.statuses },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AllNetworkStatusesResponse>(
                "AllNetworkStatusesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AllNetworkStatusesResponse {
        static instance: ::protobuf::rt::LazyV2<AllNetworkStatusesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AllNetworkStatusesResponse::new)
    }
}

impl ::protobuf::Clear for AllNetworkStatusesResponse {
    fn clear(&mut self) {
        self.statuses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AllNetworkStatusesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllNetworkStatusesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegisterNetworkExtensionRequest {
    // message fields
    resourceId: ::std::option::Option<u64>,
    name: ::std::option::Option<::protobuf::Chars>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegisterNetworkExtensionRequest {
    fn default() -> &'a RegisterNetworkExtensionRequest {
        <RegisterNetworkExtensionRequest as ::protobuf::Message>::default_instance()
    }
}

impl RegisterNetworkExtensionRequest {
    pub fn new() -> RegisterNetworkExtensionRequest {
        ::std::default::Default::default()
    }

    // required uint64 resourceId = 1;


    pub fn get_resourceId(&self) -> u64 {
        self.resourceId.unwrap_or(0)
    }
    pub fn clear_resourceId(&mut self) {
        self.resourceId = ::std::option::Option::None;
    }

    pub fn has_resourceId(&self) -> bool {
        self.resourceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceId(&mut self, v: u64) {
        self.resourceId = ::std::option::Option::Some(v);
    }

    // required string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::protobuf::Chars) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::protobuf::Chars {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::protobuf::Chars {
        self.name.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for RegisterNetworkExtensionRequest {
    fn is_initialized(&self) -> bool {
        if self.resourceId.is_none() {
            return false;
        }
        if self.name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.resourceId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.resourceId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.resourceId {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegisterNetworkExtensionRequest {
        RegisterNetworkExtensionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "resourceId",
                |m: &RegisterNetworkExtensionRequest| { &m.resourceId },
                |m: &mut RegisterNetworkExtensionRequest| { &mut m.resourceId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                "name",
                |m: &RegisterNetworkExtensionRequest| { &m.name },
                |m: &mut RegisterNetworkExtensionRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegisterNetworkExtensionRequest>(
                "RegisterNetworkExtensionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegisterNetworkExtensionRequest {
        static instance: ::protobuf::rt::LazyV2<RegisterNetworkExtensionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegisterNetworkExtensionRequest::new)
    }
}

impl ::protobuf::Clear for RegisterNetworkExtensionRequest {
    fn clear(&mut self) {
        self.resourceId = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegisterNetworkExtensionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisterNetworkExtensionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NetworkExtensionMessage {
    // message fields
    id: ::std::option::Option<u64>,
    resourceId: ::std::option::Option<u64>,
    remotePublicKey: ::std::option::Option<::bytes::Bytes>,
    data: ::std::option::Option<::bytes::Bytes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NetworkExtensionMessage {
    fn default() -> &'a NetworkExtensionMessage {
        <NetworkExtensionMessage as ::protobuf::Message>::default_instance()
    }
}

impl NetworkExtensionMessage {
    pub fn new() -> NetworkExtensionMessage {
        ::std::default::Default::default()
    }

    // required uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // required uint64 resourceId = 2;


    pub fn get_resourceId(&self) -> u64 {
        self.resourceId.unwrap_or(0)
    }
    pub fn clear_resourceId(&mut self) {
        self.resourceId = ::std::option::Option::None;
    }

    pub fn has_resourceId(&self) -> bool {
        self.resourceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceId(&mut self, v: u64) {
        self.resourceId = ::std::option::Option::Some(v);
    }

    // optional bytes remotePublicKey = 3;


    pub fn get_remotePublicKey(&self) -> &[u8] {
        match self.remotePublicKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
    pub fn clear_remotePublicKey(&mut self) {
        self.remotePublicKey = ::std::option::Option::None;
    }

    pub fn has_remotePublicKey(&self) -> bool {
        self.remotePublicKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remotePublicKey(&mut self, v: ::bytes::Bytes) {
        self.remotePublicKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remotePublicKey(&mut self) -> &mut ::bytes::Bytes {
        if self.remotePublicKey.is_none() {
            self.remotePublicKey = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.remotePublicKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_remotePublicKey(&mut self) -> ::bytes::Bytes {
        self.remotePublicKey.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // required bytes data = 4;


    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::bytes::Bytes) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::bytes::Bytes {
        self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }
}

impl ::protobuf::Message for NetworkExtensionMessage {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.resourceId.is_none() {
            return false;
        }
        if self.data.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.resourceId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_carllerche_bytes_into(wire_type, is, &mut self.remotePublicKey)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_carllerche_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.resourceId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.remotePublicKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.resourceId {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.remotePublicKey.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NetworkExtensionMessage {
        NetworkExtensionMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &NetworkExtensionMessage| { &m.id },
                |m: &mut NetworkExtensionMessage| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "resourceId",
                |m: &NetworkExtensionMessage| { &m.resourceId },
                |m: &mut NetworkExtensionMessage| { &mut m.resourceId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "remotePublicKey",
                |m: &NetworkExtensionMessage| { &m.remotePublicKey },
                |m: &mut NetworkExtensionMessage| { &mut m.remotePublicKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "data",
                |m: &NetworkExtensionMessage| { &m.data },
                |m: &mut NetworkExtensionMessage| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NetworkExtensionMessage>(
                "NetworkExtensionMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NetworkExtensionMessage {
        static instance: ::protobuf::rt::LazyV2<NetworkExtensionMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NetworkExtensionMessage::new)
    }
}

impl ::protobuf::Clear for NetworkExtensionMessage {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.resourceId = ::std::option::Option::None;
        self.remotePublicKey = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NetworkExtensionMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkExtensionMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CloseRequest {
    // message fields
    id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CloseRequest {
    fn default() -> &'a CloseRequest {
        <CloseRequest as ::protobuf::Message>::default_instance()
    }
}

impl CloseRequest {
    pub fn new() -> CloseRequest {
        ::std::default::Default::default()
    }

    // required uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CloseRequest {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CloseRequest {
        CloseRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &CloseRequest| { &m.id },
                |m: &mut CloseRequest| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CloseRequest>(
                "CloseRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CloseRequest {
        static instance: ::protobuf::rt::LazyV2<CloseRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CloseRequest::new)
    }
}

impl ::protobuf::Clear for CloseRequest {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CloseRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloseRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetRequest {
    // message fields
    id: ::std::option::Option<u32>,
    seq: ::std::option::Option<u64>,
    resourceId: ::std::option::Option<u64>,
    wait: ::std::option::Option<bool>,
    ifAvailable: ::std::option::Option<bool>,
    onWaitId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetRequest {
    fn default() -> &'a GetRequest {
        <GetRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetRequest {
    pub fn new() -> GetRequest {
        ::std::default::Default::default()
    }

    // required uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // required uint64 seq = 2;


    pub fn get_seq(&self) -> u64 {
        self.seq.unwrap_or(0)
    }
    pub fn clear_seq(&mut self) {
        self.seq = ::std::option::Option::None;
    }

    pub fn has_seq(&self) -> bool {
        self.seq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: u64) {
        self.seq = ::std::option::Option::Some(v);
    }

    // required uint64 resourceId = 3;


    pub fn get_resourceId(&self) -> u64 {
        self.resourceId.unwrap_or(0)
    }
    pub fn clear_resourceId(&mut self) {
        self.resourceId = ::std::option::Option::None;
    }

    pub fn has_resourceId(&self) -> bool {
        self.resourceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceId(&mut self, v: u64) {
        self.resourceId = ::std::option::Option::Some(v);
    }

    // optional bool wait = 4;


    pub fn get_wait(&self) -> bool {
        self.wait.unwrap_or(true)
    }
    pub fn clear_wait(&mut self) {
        self.wait = ::std::option::Option::None;
    }

    pub fn has_wait(&self) -> bool {
        self.wait.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wait(&mut self, v: bool) {
        self.wait = ::std::option::Option::Some(v);
    }

    // optional bool ifAvailable = 5;


    pub fn get_ifAvailable(&self) -> bool {
        self.ifAvailable.unwrap_or(true)
    }
    pub fn clear_ifAvailable(&mut self) {
        self.ifAvailable = ::std::option::Option::None;
    }

    pub fn has_ifAvailable(&self) -> bool {
        self.ifAvailable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ifAvailable(&mut self, v: bool) {
        self.ifAvailable = ::std::option::Option::Some(v);
    }

    // optional uint64 onWaitId = 6;


    pub fn get_onWaitId(&self) -> u64 {
        self.onWaitId.unwrap_or(0)
    }
    pub fn clear_onWaitId(&mut self) {
        self.onWaitId = ::std::option::Option::None;
    }

    pub fn has_onWaitId(&self) -> bool {
        self.onWaitId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_onWaitId(&mut self, v: u64) {
        self.onWaitId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetRequest {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.seq.is_none() {
            return false;
        }
        if self.resourceId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.seq = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.resourceId = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.wait = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ifAvailable = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.onWaitId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.resourceId {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.wait {
            my_size += 2;
        }
        if let Some(v) = self.ifAvailable {
            my_size += 2;
        }
        if let Some(v) = self.onWaitId {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.seq {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.resourceId {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.wait {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.ifAvailable {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.onWaitId {
            os.write_uint64(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetRequest {
        GetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &GetRequest| { &m.id },
                |m: &mut GetRequest| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "seq",
                |m: &GetRequest| { &m.seq },
                |m: &mut GetRequest| { &mut m.seq },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "resourceId",
                |m: &GetRequest| { &m.resourceId },
                |m: &mut GetRequest| { &mut m.resourceId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "wait",
                |m: &GetRequest| { &m.wait },
                |m: &mut GetRequest| { &mut m.wait },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ifAvailable",
                |m: &GetRequest| { &m.ifAvailable },
                |m: &mut GetRequest| { &mut m.ifAvailable },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "onWaitId",
                |m: &GetRequest| { &m.onWaitId },
                |m: &mut GetRequest| { &mut m.onWaitId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetRequest>(
                "GetRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetRequest {
        static instance: ::protobuf::rt::LazyV2<GetRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetRequest::new)
    }
}

impl ::protobuf::Clear for GetRequest {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.seq = ::std::option::Option::None;
        self.resourceId = ::std::option::Option::None;
        self.wait = ::std::option::Option::None;
        self.ifAvailable = ::std::option::Option::None;
        self.onWaitId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetResponse {
    // message fields
    block: ::std::option::Option<::bytes::Bytes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetResponse {
    fn default() -> &'a GetResponse {
        <GetResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetResponse {
    pub fn new() -> GetResponse {
        ::std::default::Default::default()
    }

    // optional bytes block = 1;


    pub fn get_block(&self) -> &[u8] {
        match self.block.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
    pub fn clear_block(&mut self) {
        self.block = ::std::option::Option::None;
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: ::bytes::Bytes) {
        self.block = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut ::bytes::Bytes {
        if self.block.is_none() {
            self.block = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> ::bytes::Bytes {
        self.block.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }
}

impl ::protobuf::Message for GetResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_carllerche_bytes_into(wire_type, is, &mut self.block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetResponse {
        GetResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "block",
                |m: &GetResponse| { &m.block },
                |m: &mut GetResponse| { &mut m.block },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetResponse>(
                "GetResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetResponse {
        static instance: ::protobuf::rt::LazyV2<GetResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetResponse::new)
    }
}

impl ::protobuf::Clear for GetResponse {
    fn clear(&mut self) {
        self.block = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AppendRequest {
    // message fields
    id: ::std::option::Option<u32>,
    pub blocks: ::std::vec::Vec<::bytes::Bytes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppendRequest {
    fn default() -> &'a AppendRequest {
        <AppendRequest as ::protobuf::Message>::default_instance()
    }
}

impl AppendRequest {
    pub fn new() -> AppendRequest {
        ::std::default::Default::default()
    }

    // required uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // repeated bytes blocks = 2;


    pub fn get_blocks(&self) -> &[::bytes::Bytes] {
        &self.blocks
    }
    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::std::vec::Vec<::bytes::Bytes>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::std::vec::Vec<::bytes::Bytes> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::std::vec::Vec<::bytes::Bytes> {
        ::std::mem::replace(&mut self.blocks, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for AppendRequest {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_carllerche_bytes_into(wire_type, is, &mut self.blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.blocks {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        for v in &self.blocks {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppendRequest {
        AppendRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &AppendRequest| { &m.id },
                |m: &mut AppendRequest| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "blocks",
                |m: &AppendRequest| { &m.blocks },
                |m: &mut AppendRequest| { &mut m.blocks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AppendRequest>(
                "AppendRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppendRequest {
        static instance: ::protobuf::rt::LazyV2<AppendRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AppendRequest::new)
    }
}

impl ::protobuf::Clear for AppendRequest {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.blocks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppendRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppendRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AppendResponse {
    // message fields
    length: ::std::option::Option<u64>,
    byteLength: ::std::option::Option<u64>,
    seq: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppendResponse {
    fn default() -> &'a AppendResponse {
        <AppendResponse as ::protobuf::Message>::default_instance()
    }
}

impl AppendResponse {
    pub fn new() -> AppendResponse {
        ::std::default::Default::default()
    }

    // required uint64 length = 1;


    pub fn get_length(&self) -> u64 {
        self.length.unwrap_or(0)
    }
    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = ::std::option::Option::Some(v);
    }

    // required uint64 byteLength = 2;


    pub fn get_byteLength(&self) -> u64 {
        self.byteLength.unwrap_or(0)
    }
    pub fn clear_byteLength(&mut self) {
        self.byteLength = ::std::option::Option::None;
    }

    pub fn has_byteLength(&self) -> bool {
        self.byteLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_byteLength(&mut self, v: u64) {
        self.byteLength = ::std::option::Option::Some(v);
    }

    // required uint64 seq = 3;


    pub fn get_seq(&self) -> u64 {
        self.seq.unwrap_or(0)
    }
    pub fn clear_seq(&mut self) {
        self.seq = ::std::option::Option::None;
    }

    pub fn has_seq(&self) -> bool {
        self.seq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: u64) {
        self.seq = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for AppendResponse {
    fn is_initialized(&self) -> bool {
        if self.length.is_none() {
            return false;
        }
        if self.byteLength.is_none() {
            return false;
        }
        if self.seq.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.byteLength = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.seq = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.byteLength {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.length {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.byteLength {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.seq {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppendResponse {
        AppendResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "length",
                |m: &AppendResponse| { &m.length },
                |m: &mut AppendResponse| { &mut m.length },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "byteLength",
                |m: &AppendResponse| { &m.byteLength },
                |m: &mut AppendResponse| { &mut m.byteLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "seq",
                |m: &AppendResponse| { &m.seq },
                |m: &mut AppendResponse| { &mut m.seq },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AppendResponse>(
                "AppendResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppendResponse {
        static instance: ::protobuf::rt::LazyV2<AppendResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AppendResponse::new)
    }
}

impl ::protobuf::Clear for AppendResponse {
    fn clear(&mut self) {
        self.length = ::std::option::Option::None;
        self.byteLength = ::std::option::Option::None;
        self.seq = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppendResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppendResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateRequest {
    // message fields
    id: ::std::option::Option<u32>,
    minLength: ::std::option::Option<u64>,
    ifAvailable: ::std::option::Option<bool>,
    hash: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateRequest {
    fn default() -> &'a UpdateRequest {
        <UpdateRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateRequest {
    pub fn new() -> UpdateRequest {
        ::std::default::Default::default()
    }

    // required uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint64 minLength = 2;


    pub fn get_minLength(&self) -> u64 {
        self.minLength.unwrap_or(0)
    }
    pub fn clear_minLength(&mut self) {
        self.minLength = ::std::option::Option::None;
    }

    pub fn has_minLength(&self) -> bool {
        self.minLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minLength(&mut self, v: u64) {
        self.minLength = ::std::option::Option::Some(v);
    }

    // optional bool ifAvailable = 3;


    pub fn get_ifAvailable(&self) -> bool {
        self.ifAvailable.unwrap_or(true)
    }
    pub fn clear_ifAvailable(&mut self) {
        self.ifAvailable = ::std::option::Option::None;
    }

    pub fn has_ifAvailable(&self) -> bool {
        self.ifAvailable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ifAvailable(&mut self, v: bool) {
        self.ifAvailable = ::std::option::Option::Some(v);
    }

    // optional bool hash = 4;


    pub fn get_hash(&self) -> bool {
        self.hash.unwrap_or(true)
    }
    pub fn clear_hash(&mut self) {
        self.hash = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: bool) {
        self.hash = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for UpdateRequest {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.minLength = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ifAvailable = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hash = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.minLength {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ifAvailable {
            my_size += 2;
        }
        if let Some(v) = self.hash {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.minLength {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.ifAvailable {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.hash {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateRequest {
        UpdateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &UpdateRequest| { &m.id },
                |m: &mut UpdateRequest| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "minLength",
                |m: &UpdateRequest| { &m.minLength },
                |m: &mut UpdateRequest| { &mut m.minLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ifAvailable",
                |m: &UpdateRequest| { &m.ifAvailable },
                |m: &mut UpdateRequest| { &mut m.ifAvailable },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hash",
                |m: &UpdateRequest| { &m.hash },
                |m: &mut UpdateRequest| { &mut m.hash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateRequest>(
                "UpdateRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateRequest::new)
    }
}

impl ::protobuf::Clear for UpdateRequest {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.minLength = ::std::option::Option::None;
        self.ifAvailable = ::std::option::Option::None;
        self.hash = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SeekRequest {
    // message fields
    id: ::std::option::Option<u32>,
    byteOffset: ::std::option::Option<u64>,
    start: ::std::option::Option<u64>,
    end: ::std::option::Option<u64>,
    wait: ::std::option::Option<bool>,
    ifAvailable: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SeekRequest {
    fn default() -> &'a SeekRequest {
        <SeekRequest as ::protobuf::Message>::default_instance()
    }
}

impl SeekRequest {
    pub fn new() -> SeekRequest {
        ::std::default::Default::default()
    }

    // required uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // required uint64 byteOffset = 2;


    pub fn get_byteOffset(&self) -> u64 {
        self.byteOffset.unwrap_or(0)
    }
    pub fn clear_byteOffset(&mut self) {
        self.byteOffset = ::std::option::Option::None;
    }

    pub fn has_byteOffset(&self) -> bool {
        self.byteOffset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_byteOffset(&mut self, v: u64) {
        self.byteOffset = ::std::option::Option::Some(v);
    }

    // optional uint64 start = 3;


    pub fn get_start(&self) -> u64 {
        self.start.unwrap_or(0)
    }
    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: u64) {
        self.start = ::std::option::Option::Some(v);
    }

    // optional uint64 end = 4;


    pub fn get_end(&self) -> u64 {
        self.end.unwrap_or(0)
    }
    pub fn clear_end(&mut self) {
        self.end = ::std::option::Option::None;
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: u64) {
        self.end = ::std::option::Option::Some(v);
    }

    // optional bool wait = 5;


    pub fn get_wait(&self) -> bool {
        self.wait.unwrap_or(true)
    }
    pub fn clear_wait(&mut self) {
        self.wait = ::std::option::Option::None;
    }

    pub fn has_wait(&self) -> bool {
        self.wait.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wait(&mut self, v: bool) {
        self.wait = ::std::option::Option::Some(v);
    }

    // optional bool ifAvailable = 6;


    pub fn get_ifAvailable(&self) -> bool {
        self.ifAvailable.unwrap_or(true)
    }
    pub fn clear_ifAvailable(&mut self) {
        self.ifAvailable = ::std::option::Option::None;
    }

    pub fn has_ifAvailable(&self) -> bool {
        self.ifAvailable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ifAvailable(&mut self, v: bool) {
        self.ifAvailable = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SeekRequest {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.byteOffset.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.byteOffset = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.end = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.wait = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ifAvailable = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.byteOffset {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.end {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.wait {
            my_size += 2;
        }
        if let Some(v) = self.ifAvailable {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.byteOffset {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.start {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.end {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.wait {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.ifAvailable {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SeekRequest {
        SeekRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &SeekRequest| { &m.id },
                |m: &mut SeekRequest| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "byteOffset",
                |m: &SeekRequest| { &m.byteOffset },
                |m: &mut SeekRequest| { &mut m.byteOffset },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "start",
                |m: &SeekRequest| { &m.start },
                |m: &mut SeekRequest| { &mut m.start },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "end",
                |m: &SeekRequest| { &m.end },
                |m: &mut SeekRequest| { &mut m.end },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "wait",
                |m: &SeekRequest| { &m.wait },
                |m: &mut SeekRequest| { &mut m.wait },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ifAvailable",
                |m: &SeekRequest| { &m.ifAvailable },
                |m: &mut SeekRequest| { &mut m.ifAvailable },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SeekRequest>(
                "SeekRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SeekRequest {
        static instance: ::protobuf::rt::LazyV2<SeekRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SeekRequest::new)
    }
}

impl ::protobuf::Clear for SeekRequest {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.byteOffset = ::std::option::Option::None;
        self.start = ::std::option::Option::None;
        self.end = ::std::option::Option::None;
        self.wait = ::std::option::Option::None;
        self.ifAvailable = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SeekRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SeekRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SeekResponse {
    // message fields
    seq: ::std::option::Option<u64>,
    blockOffset: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SeekResponse {
    fn default() -> &'a SeekResponse {
        <SeekResponse as ::protobuf::Message>::default_instance()
    }
}

impl SeekResponse {
    pub fn new() -> SeekResponse {
        ::std::default::Default::default()
    }

    // required uint64 seq = 1;


    pub fn get_seq(&self) -> u64 {
        self.seq.unwrap_or(0)
    }
    pub fn clear_seq(&mut self) {
        self.seq = ::std::option::Option::None;
    }

    pub fn has_seq(&self) -> bool {
        self.seq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: u64) {
        self.seq = ::std::option::Option::Some(v);
    }

    // required uint64 blockOffset = 2;


    pub fn get_blockOffset(&self) -> u64 {
        self.blockOffset.unwrap_or(0)
    }
    pub fn clear_blockOffset(&mut self) {
        self.blockOffset = ::std::option::Option::None;
    }

    pub fn has_blockOffset(&self) -> bool {
        self.blockOffset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockOffset(&mut self, v: u64) {
        self.blockOffset = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SeekResponse {
    fn is_initialized(&self) -> bool {
        if self.seq.is_none() {
            return false;
        }
        if self.blockOffset.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.seq = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockOffset = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.seq {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blockOffset {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.seq {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.blockOffset {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SeekResponse {
        SeekResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "seq",
                |m: &SeekResponse| { &m.seq },
                |m: &mut SeekResponse| { &mut m.seq },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "blockOffset",
                |m: &SeekResponse| { &m.blockOffset },
                |m: &mut SeekResponse| { &mut m.blockOffset },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SeekResponse>(
                "SeekResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SeekResponse {
        static instance: ::protobuf::rt::LazyV2<SeekResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SeekResponse::new)
    }
}

impl ::protobuf::Clear for SeekResponse {
    fn clear(&mut self) {
        self.seq = ::std::option::Option::None;
        self.blockOffset = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SeekResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SeekResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HasRequest {
    // message fields
    id: ::std::option::Option<u32>,
    seq: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HasRequest {
    fn default() -> &'a HasRequest {
        <HasRequest as ::protobuf::Message>::default_instance()
    }
}

impl HasRequest {
    pub fn new() -> HasRequest {
        ::std::default::Default::default()
    }

    // required uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // required uint64 seq = 2;


    pub fn get_seq(&self) -> u64 {
        self.seq.unwrap_or(0)
    }
    pub fn clear_seq(&mut self) {
        self.seq = ::std::option::Option::None;
    }

    pub fn has_seq(&self) -> bool {
        self.seq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: u64) {
        self.seq = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for HasRequest {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.seq.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.seq = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.seq {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HasRequest {
        HasRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &HasRequest| { &m.id },
                |m: &mut HasRequest| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "seq",
                |m: &HasRequest| { &m.seq },
                |m: &mut HasRequest| { &mut m.seq },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HasRequest>(
                "HasRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HasRequest {
        static instance: ::protobuf::rt::LazyV2<HasRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HasRequest::new)
    }
}

impl ::protobuf::Clear for HasRequest {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.seq = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HasRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HasRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HasResponse {
    // message fields
    has: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HasResponse {
    fn default() -> &'a HasResponse {
        <HasResponse as ::protobuf::Message>::default_instance()
    }
}

impl HasResponse {
    pub fn new() -> HasResponse {
        ::std::default::Default::default()
    }

    // required bool has = 1;


    pub fn get_has(&self) -> bool {
        self.has.unwrap_or(false)
    }
    pub fn clear_has(&mut self) {
        self.has = ::std::option::Option::None;
    }

    pub fn has_has(&self) -> bool {
        self.has.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has(&mut self, v: bool) {
        self.has = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for HasResponse {
    fn is_initialized(&self) -> bool {
        if self.has.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.has {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.has {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HasResponse {
        HasResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has",
                |m: &HasResponse| { &m.has },
                |m: &mut HasResponse| { &mut m.has },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HasResponse>(
                "HasResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HasResponse {
        static instance: ::protobuf::rt::LazyV2<HasResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HasResponse::new)
    }
}

impl ::protobuf::Clear for HasResponse {
    fn clear(&mut self) {
        self.has = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HasResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HasResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CancelRequest {
    // message fields
    id: ::std::option::Option<u64>,
    resourceId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CancelRequest {
    fn default() -> &'a CancelRequest {
        <CancelRequest as ::protobuf::Message>::default_instance()
    }
}

impl CancelRequest {
    pub fn new() -> CancelRequest {
        ::std::default::Default::default()
    }

    // required uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // required uint64 resourceId = 2;


    pub fn get_resourceId(&self) -> u64 {
        self.resourceId.unwrap_or(0)
    }
    pub fn clear_resourceId(&mut self) {
        self.resourceId = ::std::option::Option::None;
    }

    pub fn has_resourceId(&self) -> bool {
        self.resourceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceId(&mut self, v: u64) {
        self.resourceId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CancelRequest {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.resourceId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.resourceId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.resourceId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.resourceId {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CancelRequest {
        CancelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &CancelRequest| { &m.id },
                |m: &mut CancelRequest| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "resourceId",
                |m: &CancelRequest| { &m.resourceId },
                |m: &mut CancelRequest| { &mut m.resourceId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CancelRequest>(
                "CancelRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CancelRequest {
        static instance: ::protobuf::rt::LazyV2<CancelRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CancelRequest::new)
    }
}

impl ::protobuf::Clear for CancelRequest {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.resourceId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CancelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DownloadRequest {
    // message fields
    id: ::std::option::Option<u64>,
    resourceId: ::std::option::Option<u64>,
    start: ::std::option::Option<u64>,
    end: ::std::option::Option<u64>,
    pub blocks: ::std::vec::Vec<u64>,
    linear: ::std::option::Option<bool>,
    live: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DownloadRequest {
    fn default() -> &'a DownloadRequest {
        <DownloadRequest as ::protobuf::Message>::default_instance()
    }
}

impl DownloadRequest {
    pub fn new() -> DownloadRequest {
        ::std::default::Default::default()
    }

    // required uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // required uint64 resourceId = 2;


    pub fn get_resourceId(&self) -> u64 {
        self.resourceId.unwrap_or(0)
    }
    pub fn clear_resourceId(&mut self) {
        self.resourceId = ::std::option::Option::None;
    }

    pub fn has_resourceId(&self) -> bool {
        self.resourceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceId(&mut self, v: u64) {
        self.resourceId = ::std::option::Option::Some(v);
    }

    // optional uint64 start = 3;


    pub fn get_start(&self) -> u64 {
        self.start.unwrap_or(0)
    }
    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: u64) {
        self.start = ::std::option::Option::Some(v);
    }

    // optional uint64 end = 4;


    pub fn get_end(&self) -> u64 {
        self.end.unwrap_or(0)
    }
    pub fn clear_end(&mut self) {
        self.end = ::std::option::Option::None;
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: u64) {
        self.end = ::std::option::Option::Some(v);
    }

    // repeated uint64 blocks = 5;


    pub fn get_blocks(&self) -> &[u64] {
        &self.blocks
    }
    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::std::vec::Vec<u64>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.blocks, ::std::vec::Vec::new())
    }

    // optional bool linear = 6;


    pub fn get_linear(&self) -> bool {
        self.linear.unwrap_or(false)
    }
    pub fn clear_linear(&mut self) {
        self.linear = ::std::option::Option::None;
    }

    pub fn has_linear(&self) -> bool {
        self.linear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_linear(&mut self, v: bool) {
        self.linear = ::std::option::Option::Some(v);
    }

    // optional bool live = 7;


    pub fn get_live(&self) -> bool {
        self.live.unwrap_or(false)
    }
    pub fn clear_live(&mut self) {
        self.live = ::std::option::Option::None;
    }

    pub fn has_live(&self) -> bool {
        self.live.is_some()
    }

    // Param is passed by value, moved
    pub fn set_live(&mut self, v: bool) {
        self.live = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DownloadRequest {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.resourceId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.resourceId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.end = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.blocks)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.linear = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.live = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.resourceId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.end {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.blocks {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.linear {
            my_size += 2;
        }
        if let Some(v) = self.live {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.resourceId {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.start {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.end {
            os.write_uint64(4, v)?;
        }
        for v in &self.blocks {
            os.write_uint64(5, *v)?;
        };
        if let Some(v) = self.linear {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.live {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DownloadRequest {
        DownloadRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &DownloadRequest| { &m.id },
                |m: &mut DownloadRequest| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "resourceId",
                |m: &DownloadRequest| { &m.resourceId },
                |m: &mut DownloadRequest| { &mut m.resourceId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "start",
                |m: &DownloadRequest| { &m.start },
                |m: &mut DownloadRequest| { &mut m.start },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "end",
                |m: &DownloadRequest| { &m.end },
                |m: &mut DownloadRequest| { &mut m.end },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "blocks",
                |m: &DownloadRequest| { &m.blocks },
                |m: &mut DownloadRequest| { &mut m.blocks },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "linear",
                |m: &DownloadRequest| { &m.linear },
                |m: &mut DownloadRequest| { &mut m.linear },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "live",
                |m: &DownloadRequest| { &m.live },
                |m: &mut DownloadRequest| { &mut m.live },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DownloadRequest>(
                "DownloadRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DownloadRequest {
        static instance: ::protobuf::rt::LazyV2<DownloadRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DownloadRequest::new)
    }
}

impl ::protobuf::Clear for DownloadRequest {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.resourceId = ::std::option::Option::None;
        self.start = ::std::option::Option::None;
        self.end = ::std::option::Option::None;
        self.blocks.clear();
        self.linear = ::std::option::Option::None;
        self.live = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DownloadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DownloadRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DownloadedRequest {
    // message fields
    id: ::std::option::Option<u64>,
    start: ::std::option::Option<u64>,
    end: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DownloadedRequest {
    fn default() -> &'a DownloadedRequest {
        <DownloadedRequest as ::protobuf::Message>::default_instance()
    }
}

impl DownloadedRequest {
    pub fn new() -> DownloadedRequest {
        ::std::default::Default::default()
    }

    // required uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint64 start = 2;


    pub fn get_start(&self) -> u64 {
        self.start.unwrap_or(0)
    }
    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: u64) {
        self.start = ::std::option::Option::Some(v);
    }

    // optional uint64 end = 3;


    pub fn get_end(&self) -> u64 {
        self.end.unwrap_or(0)
    }
    pub fn clear_end(&mut self) {
        self.end = ::std::option::Option::None;
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: u64) {
        self.end = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DownloadedRequest {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.end = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.end {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.start {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.end {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DownloadedRequest {
        DownloadedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &DownloadedRequest| { &m.id },
                |m: &mut DownloadedRequest| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "start",
                |m: &DownloadedRequest| { &m.start },
                |m: &mut DownloadedRequest| { &mut m.start },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "end",
                |m: &DownloadedRequest| { &m.end },
                |m: &mut DownloadedRequest| { &mut m.end },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DownloadedRequest>(
                "DownloadedRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DownloadedRequest {
        static instance: ::protobuf::rt::LazyV2<DownloadedRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DownloadedRequest::new)
    }
}

impl ::protobuf::Clear for DownloadedRequest {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.start = ::std::option::Option::None;
        self.end = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DownloadedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DownloadedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DownloadedResponse {
    // message fields
    bytes: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DownloadedResponse {
    fn default() -> &'a DownloadedResponse {
        <DownloadedResponse as ::protobuf::Message>::default_instance()
    }
}

impl DownloadedResponse {
    pub fn new() -> DownloadedResponse {
        ::std::default::Default::default()
    }

    // required uint64 bytes = 1;


    pub fn get_bytes(&self) -> u64 {
        self.bytes.unwrap_or(0)
    }
    pub fn clear_bytes(&mut self) {
        self.bytes = ::std::option::Option::None;
    }

    pub fn has_bytes(&self) -> bool {
        self.bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: u64) {
        self.bytes = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DownloadedResponse {
    fn is_initialized(&self) -> bool {
        if self.bytes.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bytes {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bytes {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DownloadedResponse {
        DownloadedResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "bytes",
                |m: &DownloadedResponse| { &m.bytes },
                |m: &mut DownloadedResponse| { &mut m.bytes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DownloadedResponse>(
                "DownloadedResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DownloadedResponse {
        static instance: ::protobuf::rt::LazyV2<DownloadedResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DownloadedResponse::new)
    }
}

impl ::protobuf::Clear for DownloadedResponse {
    fn clear(&mut self) {
        self.bytes = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DownloadedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DownloadedResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UndownloadRequest {
    // message fields
    id: ::std::option::Option<u64>,
    resourceId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UndownloadRequest {
    fn default() -> &'a UndownloadRequest {
        <UndownloadRequest as ::protobuf::Message>::default_instance()
    }
}

impl UndownloadRequest {
    pub fn new() -> UndownloadRequest {
        ::std::default::Default::default()
    }

    // required uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // required uint64 resourceId = 2;


    pub fn get_resourceId(&self) -> u64 {
        self.resourceId.unwrap_or(0)
    }
    pub fn clear_resourceId(&mut self) {
        self.resourceId = ::std::option::Option::None;
    }

    pub fn has_resourceId(&self) -> bool {
        self.resourceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceId(&mut self, v: u64) {
        self.resourceId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for UndownloadRequest {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.resourceId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.resourceId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.resourceId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.resourceId {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UndownloadRequest {
        UndownloadRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &UndownloadRequest| { &m.id },
                |m: &mut UndownloadRequest| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "resourceId",
                |m: &UndownloadRequest| { &m.resourceId },
                |m: &mut UndownloadRequest| { &mut m.resourceId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UndownloadRequest>(
                "UndownloadRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UndownloadRequest {
        static instance: ::protobuf::rt::LazyV2<UndownloadRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UndownloadRequest::new)
    }
}

impl ::protobuf::Clear for UndownloadRequest {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.resourceId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UndownloadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UndownloadRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LockRequest {
    // message fields
    id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LockRequest {
    fn default() -> &'a LockRequest {
        <LockRequest as ::protobuf::Message>::default_instance()
    }
}

impl LockRequest {
    pub fn new() -> LockRequest {
        ::std::default::Default::default()
    }

    // required uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for LockRequest {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LockRequest {
        LockRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &LockRequest| { &m.id },
                |m: &mut LockRequest| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LockRequest>(
                "LockRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LockRequest {
        static instance: ::protobuf::rt::LazyV2<LockRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LockRequest::new)
    }
}

impl ::protobuf::Clear for LockRequest {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LockRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LockRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WatchDownloadsRequest {
    // message fields
    id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WatchDownloadsRequest {
    fn default() -> &'a WatchDownloadsRequest {
        <WatchDownloadsRequest as ::protobuf::Message>::default_instance()
    }
}

impl WatchDownloadsRequest {
    pub fn new() -> WatchDownloadsRequest {
        ::std::default::Default::default()
    }

    // required uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for WatchDownloadsRequest {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WatchDownloadsRequest {
        WatchDownloadsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &WatchDownloadsRequest| { &m.id },
                |m: &mut WatchDownloadsRequest| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WatchDownloadsRequest>(
                "WatchDownloadsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WatchDownloadsRequest {
        static instance: ::protobuf::rt::LazyV2<WatchDownloadsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WatchDownloadsRequest::new)
    }
}

impl ::protobuf::Clear for WatchDownloadsRequest {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WatchDownloadsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WatchDownloadsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnwatchDownloadsRequest {
    // message fields
    id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnwatchDownloadsRequest {
    fn default() -> &'a UnwatchDownloadsRequest {
        <UnwatchDownloadsRequest as ::protobuf::Message>::default_instance()
    }
}

impl UnwatchDownloadsRequest {
    pub fn new() -> UnwatchDownloadsRequest {
        ::std::default::Default::default()
    }

    // required uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for UnwatchDownloadsRequest {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnwatchDownloadsRequest {
        UnwatchDownloadsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &UnwatchDownloadsRequest| { &m.id },
                |m: &mut UnwatchDownloadsRequest| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnwatchDownloadsRequest>(
                "UnwatchDownloadsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnwatchDownloadsRequest {
        static instance: ::protobuf::rt::LazyV2<UnwatchDownloadsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnwatchDownloadsRequest::new)
    }
}

impl ::protobuf::Clear for UnwatchDownloadsRequest {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnwatchDownloadsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnwatchDownloadsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AppendEvent {
    // message fields
    id: ::std::option::Option<u64>,
    length: ::std::option::Option<u64>,
    byteLength: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppendEvent {
    fn default() -> &'a AppendEvent {
        <AppendEvent as ::protobuf::Message>::default_instance()
    }
}

impl AppendEvent {
    pub fn new() -> AppendEvent {
        ::std::default::Default::default()
    }

    // required uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // required uint64 length = 2;


    pub fn get_length(&self) -> u64 {
        self.length.unwrap_or(0)
    }
    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = ::std::option::Option::Some(v);
    }

    // required uint64 byteLength = 3;


    pub fn get_byteLength(&self) -> u64 {
        self.byteLength.unwrap_or(0)
    }
    pub fn clear_byteLength(&mut self) {
        self.byteLength = ::std::option::Option::None;
    }

    pub fn has_byteLength(&self) -> bool {
        self.byteLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_byteLength(&mut self, v: u64) {
        self.byteLength = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for AppendEvent {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.length.is_none() {
            return false;
        }
        if self.byteLength.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.byteLength = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.byteLength {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.length {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.byteLength {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppendEvent {
        AppendEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &AppendEvent| { &m.id },
                |m: &mut AppendEvent| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "length",
                |m: &AppendEvent| { &m.length },
                |m: &mut AppendEvent| { &mut m.length },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "byteLength",
                |m: &AppendEvent| { &m.byteLength },
                |m: &mut AppendEvent| { &mut m.byteLength },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AppendEvent>(
                "AppendEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppendEvent {
        static instance: ::protobuf::rt::LazyV2<AppendEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AppendEvent::new)
    }
}

impl ::protobuf::Clear for AppendEvent {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.length = ::std::option::Option::None;
        self.byteLength = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppendEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppendEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PeerEvent {
    // message fields
    id: ::std::option::Option<u64>,
    pub peer: ::protobuf::SingularPtrField<Peer>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PeerEvent {
    fn default() -> &'a PeerEvent {
        <PeerEvent as ::protobuf::Message>::default_instance()
    }
}

impl PeerEvent {
    pub fn new() -> PeerEvent {
        ::std::default::Default::default()
    }

    // required uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // required .hyperspace.Peer peer = 2;


    pub fn get_peer(&self) -> &Peer {
        self.peer.as_ref().unwrap_or_else(|| <Peer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_peer(&mut self) {
        self.peer.clear();
    }

    pub fn has_peer(&self) -> bool {
        self.peer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer(&mut self, v: Peer) {
        self.peer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peer(&mut self) -> &mut Peer {
        if self.peer.is_none() {
            self.peer.set_default();
        }
        self.peer.as_mut().unwrap()
    }

    // Take field
    pub fn take_peer(&mut self) -> Peer {
        self.peer.take().unwrap_or_else(|| Peer::new())
    }
}

impl ::protobuf::Message for PeerEvent {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.peer.is_none() {
            return false;
        }
        for v in &self.peer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.peer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.peer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.peer.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PeerEvent {
        PeerEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &PeerEvent| { &m.id },
                |m: &mut PeerEvent| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Peer>>(
                "peer",
                |m: &PeerEvent| { &m.peer },
                |m: &mut PeerEvent| { &mut m.peer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PeerEvent>(
                "PeerEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PeerEvent {
        static instance: ::protobuf::rt::LazyV2<PeerEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PeerEvent::new)
    }
}

impl ::protobuf::Clear for PeerEvent {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.peer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PeerEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CloseEvent {
    // message fields
    id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CloseEvent {
    fn default() -> &'a CloseEvent {
        <CloseEvent as ::protobuf::Message>::default_instance()
    }
}

impl CloseEvent {
    pub fn new() -> CloseEvent {
        ::std::default::Default::default()
    }

    // required uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CloseEvent {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CloseEvent {
        CloseEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &CloseEvent| { &m.id },
                |m: &mut CloseEvent| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CloseEvent>(
                "CloseEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CloseEvent {
        static instance: ::protobuf::rt::LazyV2<CloseEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CloseEvent::new)
    }
}

impl ::protobuf::Clear for CloseEvent {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CloseEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloseEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WaitEvent {
    // message fields
    id: ::std::option::Option<u64>,
    onWaitId: ::std::option::Option<u64>,
    seq: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WaitEvent {
    fn default() -> &'a WaitEvent {
        <WaitEvent as ::protobuf::Message>::default_instance()
    }
}

impl WaitEvent {
    pub fn new() -> WaitEvent {
        ::std::default::Default::default()
    }

    // required uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // required uint64 onWaitId = 2;


    pub fn get_onWaitId(&self) -> u64 {
        self.onWaitId.unwrap_or(0)
    }
    pub fn clear_onWaitId(&mut self) {
        self.onWaitId = ::std::option::Option::None;
    }

    pub fn has_onWaitId(&self) -> bool {
        self.onWaitId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_onWaitId(&mut self, v: u64) {
        self.onWaitId = ::std::option::Option::Some(v);
    }

    // required uint64 seq = 3;


    pub fn get_seq(&self) -> u64 {
        self.seq.unwrap_or(0)
    }
    pub fn clear_seq(&mut self) {
        self.seq = ::std::option::Option::None;
    }

    pub fn has_seq(&self) -> bool {
        self.seq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: u64) {
        self.seq = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for WaitEvent {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.onWaitId.is_none() {
            return false;
        }
        if self.seq.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.onWaitId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.seq = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.onWaitId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.onWaitId {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.seq {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WaitEvent {
        WaitEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &WaitEvent| { &m.id },
                |m: &mut WaitEvent| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "onWaitId",
                |m: &WaitEvent| { &m.onWaitId },
                |m: &mut WaitEvent| { &mut m.onWaitId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "seq",
                |m: &WaitEvent| { &m.seq },
                |m: &mut WaitEvent| { &mut m.seq },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WaitEvent>(
                "WaitEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WaitEvent {
        static instance: ::protobuf::rt::LazyV2<WaitEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WaitEvent::new)
    }
}

impl ::protobuf::Clear for WaitEvent {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.onWaitId = ::std::option::Option::None;
        self.seq = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WaitEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WaitEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DownloadEvent {
    // message fields
    id: ::std::option::Option<u64>,
    seq: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DownloadEvent {
    fn default() -> &'a DownloadEvent {
        <DownloadEvent as ::protobuf::Message>::default_instance()
    }
}

impl DownloadEvent {
    pub fn new() -> DownloadEvent {
        ::std::default::Default::default()
    }

    // required uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // required uint64 seq = 2;


    pub fn get_seq(&self) -> u64 {
        self.seq.unwrap_or(0)
    }
    pub fn clear_seq(&mut self) {
        self.seq = ::std::option::Option::None;
    }

    pub fn has_seq(&self) -> bool {
        self.seq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: u64) {
        self.seq = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DownloadEvent {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.seq.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.seq = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.seq {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DownloadEvent {
        DownloadEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &DownloadEvent| { &m.id },
                |m: &mut DownloadEvent| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "seq",
                |m: &DownloadEvent| { &m.seq },
                |m: &mut DownloadEvent| { &mut m.seq },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DownloadEvent>(
                "DownloadEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DownloadEvent {
        static instance: ::protobuf::rt::LazyV2<DownloadEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DownloadEvent::new)
    }
}

impl ::protobuf::Clear for DownloadEvent {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.seq = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DownloadEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DownloadEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegisterExtensionRequest {
    // message fields
    id: ::std::option::Option<u64>,
    resourceId: ::std::option::Option<u64>,
    name: ::std::option::Option<::protobuf::Chars>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegisterExtensionRequest {
    fn default() -> &'a RegisterExtensionRequest {
        <RegisterExtensionRequest as ::protobuf::Message>::default_instance()
    }
}

impl RegisterExtensionRequest {
    pub fn new() -> RegisterExtensionRequest {
        ::std::default::Default::default()
    }

    // required uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // required uint64 resourceId = 2;


    pub fn get_resourceId(&self) -> u64 {
        self.resourceId.unwrap_or(0)
    }
    pub fn clear_resourceId(&mut self) {
        self.resourceId = ::std::option::Option::None;
    }

    pub fn has_resourceId(&self) -> bool {
        self.resourceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceId(&mut self, v: u64) {
        self.resourceId = ::std::option::Option::Some(v);
    }

    // required string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::protobuf::Chars) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::protobuf::Chars {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::protobuf::Chars {
        self.name.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for RegisterExtensionRequest {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.resourceId.is_none() {
            return false;
        }
        if self.name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.resourceId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_carllerche_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.resourceId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.resourceId {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegisterExtensionRequest {
        RegisterExtensionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &RegisterExtensionRequest| { &m.id },
                |m: &mut RegisterExtensionRequest| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "resourceId",
                |m: &RegisterExtensionRequest| { &m.resourceId },
                |m: &mut RegisterExtensionRequest| { &mut m.resourceId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                "name",
                |m: &RegisterExtensionRequest| { &m.name },
                |m: &mut RegisterExtensionRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegisterExtensionRequest>(
                "RegisterExtensionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegisterExtensionRequest {
        static instance: ::protobuf::rt::LazyV2<RegisterExtensionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegisterExtensionRequest::new)
    }
}

impl ::protobuf::Clear for RegisterExtensionRequest {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.resourceId = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegisterExtensionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisterExtensionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnregisterExtensionRequest {
    // message fields
    id: ::std::option::Option<u64>,
    resourceId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnregisterExtensionRequest {
    fn default() -> &'a UnregisterExtensionRequest {
        <UnregisterExtensionRequest as ::protobuf::Message>::default_instance()
    }
}

impl UnregisterExtensionRequest {
    pub fn new() -> UnregisterExtensionRequest {
        ::std::default::Default::default()
    }

    // required uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // required uint64 resourceId = 2;


    pub fn get_resourceId(&self) -> u64 {
        self.resourceId.unwrap_or(0)
    }
    pub fn clear_resourceId(&mut self) {
        self.resourceId = ::std::option::Option::None;
    }

    pub fn has_resourceId(&self) -> bool {
        self.resourceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceId(&mut self, v: u64) {
        self.resourceId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for UnregisterExtensionRequest {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.resourceId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.resourceId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.resourceId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.resourceId {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnregisterExtensionRequest {
        UnregisterExtensionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &UnregisterExtensionRequest| { &m.id },
                |m: &mut UnregisterExtensionRequest| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "resourceId",
                |m: &UnregisterExtensionRequest| { &m.resourceId },
                |m: &mut UnregisterExtensionRequest| { &mut m.resourceId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnregisterExtensionRequest>(
                "UnregisterExtensionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnregisterExtensionRequest {
        static instance: ::protobuf::rt::LazyV2<UnregisterExtensionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnregisterExtensionRequest::new)
    }
}

impl ::protobuf::Clear for UnregisterExtensionRequest {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.resourceId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnregisterExtensionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnregisterExtensionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExtensionMessage {
    // message fields
    id: ::std::option::Option<u64>,
    resourceId: ::std::option::Option<u64>,
    remotePublicKey: ::std::option::Option<::bytes::Bytes>,
    data: ::std::option::Option<::bytes::Bytes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExtensionMessage {
    fn default() -> &'a ExtensionMessage {
        <ExtensionMessage as ::protobuf::Message>::default_instance()
    }
}

impl ExtensionMessage {
    pub fn new() -> ExtensionMessage {
        ::std::default::Default::default()
    }

    // required uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // required uint64 resourceId = 2;


    pub fn get_resourceId(&self) -> u64 {
        self.resourceId.unwrap_or(0)
    }
    pub fn clear_resourceId(&mut self) {
        self.resourceId = ::std::option::Option::None;
    }

    pub fn has_resourceId(&self) -> bool {
        self.resourceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceId(&mut self, v: u64) {
        self.resourceId = ::std::option::Option::Some(v);
    }

    // optional bytes remotePublicKey = 3;


    pub fn get_remotePublicKey(&self) -> &[u8] {
        match self.remotePublicKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
    pub fn clear_remotePublicKey(&mut self) {
        self.remotePublicKey = ::std::option::Option::None;
    }

    pub fn has_remotePublicKey(&self) -> bool {
        self.remotePublicKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remotePublicKey(&mut self, v: ::bytes::Bytes) {
        self.remotePublicKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remotePublicKey(&mut self) -> &mut ::bytes::Bytes {
        if self.remotePublicKey.is_none() {
            self.remotePublicKey = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.remotePublicKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_remotePublicKey(&mut self) -> ::bytes::Bytes {
        self.remotePublicKey.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // required bytes data = 4;


    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }
    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::bytes::Bytes) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::bytes::Bytes {
        self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }
}

impl ::protobuf::Message for ExtensionMessage {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.resourceId.is_none() {
            return false;
        }
        if self.data.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.resourceId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_carllerche_bytes_into(wire_type, is, &mut self.remotePublicKey)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_carllerche_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.resourceId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.remotePublicKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.resourceId {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.remotePublicKey.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExtensionMessage {
        ExtensionMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &ExtensionMessage| { &m.id },
                |m: &mut ExtensionMessage| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "resourceId",
                |m: &ExtensionMessage| { &m.resourceId },
                |m: &mut ExtensionMessage| { &mut m.resourceId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "remotePublicKey",
                |m: &ExtensionMessage| { &m.remotePublicKey },
                |m: &mut ExtensionMessage| { &mut m.remotePublicKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "data",
                |m: &ExtensionMessage| { &m.data },
                |m: &mut ExtensionMessage| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExtensionMessage>(
                "ExtensionMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExtensionMessage {
        static instance: ::protobuf::rt::LazyV2<ExtensionMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExtensionMessage::new)
    }
}

impl ::protobuf::Clear for ExtensionMessage {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.resourceId = ::std::option::Option::None;
        self.remotePublicKey = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExtensionMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtensionMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0cschema.proto\x12\nhyperspace\"r\n\x04Peer\x12*\n\x0fremotePublicKe\
    y\x18\x01\x20\x02(\x0cR\x0fremotePublicKeyB\0\x12&\n\rremoteAddress\x18\
    \x02\x20\x02(\tR\rremoteAddressB\0\x12\x14\n\x04type\x18\x03\x20\x02(\tR\
    \x04typeB\0:\0\"\x8e\x01\n\x18HyperspaceStatusResponse\x12\x20\n\napiVer\
    sion\x18\x01\x20\x02(\tR\napiVersionB\0\x12&\n\rholepunchable\x18\x02\
    \x20\x01(\x08R\rholepunchableB\0\x12&\n\rremoteAddress\x18\x03\x20\x01(\
    \tR\rremoteAddressB\0:\0\"a\n\x0bOpenRequest\x12\x10\n\x02id\x18\x01\x20\
    \x02(\rR\x02idB\0\x12\x12\n\x03key\x18\x02\x20\x01(\x0cR\x03keyB\0\x12\
    \x14\n\x04name\x18\x03\x20\x01(\tR\x04nameB\0\x12\x14\n\x04weak\x18\x04\
    \x20\x01(\x08R\x04weakB\0:\0\"\xa8\x01\n\x0cOpenResponse\x12\x12\n\x03ke\
    y\x18\x01\x20\x02(\x0cR\x03keyB\0\x12\x18\n\x06length\x18\x02\x20\x02(\
    \x04R\x06lengthB\0\x12\x20\n\nbyteLength\x18\x03\x20\x02(\x04R\nbyteLeng\
    thB\0\x12\x1c\n\x08writable\x18\x04\x20\x02(\x08R\x08writableB\0\x12(\n\
    \x05peers\x18\x05\x20\x03(\x0b2\x10.hyperspace.PeerR\x05peersB\0:\0\"!\n\
    \tFeedEvent\x12\x12\n\x03key\x18\x01\x20\x02(\x0cR\x03keyB\0:\0\"a\n\x13\
    OpenNetworkResponse\x12\x1e\n\tpublicKey\x18\x01\x20\x02(\x0cR\tpublicKe\
    yB\0\x12(\n\x05peers\x18\x02\x20\x03(\x0b2\x10.hyperspace.PeerR\x05peers\
    B\0:\0\"\x8d\x01\n\rNetworkStatus\x12$\n\x0cdiscoveryKey\x18\x01\x20\x02\
    (\x0cR\x0cdiscoveryKeyB\0\x12\x1c\n\x08announce\x18\x02\x20\x01(\x08R\
    \x08announceB\0\x12\x18\n\x06lookup\x18\x03\x20\x01(\x08R\x06lookupB\0\
    \x12\x1c\n\x08remember\x18\x04\x20\x01(\x08R\x08rememberB\0:\0\"\xba\x01\
    \n\x17ConfigureNetworkRequest\x12A\n\rconfiguration\x18\x01\x20\x02(\x0b\
    2\x19.hyperspace.NetworkStatusR\rconfigurationB\0\x12\x16\n\x05flush\x18\
    \x02\x20\x01(\x08R\x05flushB\0\x12\x1c\n\x08copyFrom\x18\x03\x20\x01(\
    \x0cR\x08copyFromB\0\x12$\n\toverwrite\x18\x04\x20\x01(\x08:\x04trueR\to\
    verwriteB\0:\0\">\n\x14NetworkStatusRequest\x12$\n\x0cdiscoveryKey\x18\
    \x01\x20\x02(\x0cR\x0cdiscoveryKeyB\0:\0\"N\n\x15NetworkStatusResponse\
    \x123\n\x06status\x18\x01\x20\x01(\x0b2\x19.hyperspace.NetworkStatusR\
    \x06statusB\0:\0\"W\n\x1aAllNetworkStatusesResponse\x127\n\x08statuses\
    \x18\x01\x20\x03(\x0b2\x19.hyperspace.NetworkStatusR\x08statusesB\0:\0\"\
    [\n\x1fRegisterNetworkExtensionRequest\x12\x20\n\nresourceId\x18\x01\x20\
    \x02(\x04R\nresourceIdB\0\x12\x14\n\x04name\x18\x02\x20\x02(\tR\x04nameB\
    \0:\0\"\x91\x01\n\x17NetworkExtensionMessage\x12\x10\n\x02id\x18\x01\x20\
    \x02(\x04R\x02idB\0\x12\x20\n\nresourceId\x18\x02\x20\x02(\x04R\nresourc\
    eIdB\0\x12*\n\x0fremotePublicKey\x18\x03\x20\x01(\x0cR\x0fremotePublicKe\
    yB\0\x12\x14\n\x04data\x18\x04\x20\x02(\x0cR\x04dataB\0:\0\"\"\n\x0cClos\
    eRequest\x12\x10\n\x02id\x18\x01\x20\x02(\rR\x02idB\0:\0\"\xba\x01\n\nGe\
    tRequest\x12\x10\n\x02id\x18\x01\x20\x02(\rR\x02idB\0\x12\x12\n\x03seq\
    \x18\x02\x20\x02(\x04R\x03seqB\0\x12\x20\n\nresourceId\x18\x03\x20\x02(\
    \x04R\nresourceIdB\0\x12\x1a\n\x04wait\x18\x04\x20\x01(\x08:\x04trueR\
    \x04waitB\0\x12(\n\x0bifAvailable\x18\x05\x20\x01(\x08:\x04trueR\x0bifAv\
    ailableB\0\x12\x1c\n\x08onWaitId\x18\x06\x20\x01(\x04R\x08onWaitIdB\0:\0\
    \"'\n\x0bGetResponse\x12\x16\n\x05block\x18\x01\x20\x01(\x0cR\x05blockB\
    \0:\0\"=\n\rAppendRequest\x12\x10\n\x02id\x18\x01\x20\x02(\rR\x02idB\0\
    \x12\x18\n\x06blocks\x18\x02\x20\x03(\x0cR\x06blocksB\0:\0\"b\n\x0eAppen\
    dResponse\x12\x18\n\x06length\x18\x01\x20\x02(\x04R\x06lengthB\0\x12\x20\
    \n\nbyteLength\x18\x02\x20\x02(\x04R\nbyteLengthB\0\x12\x12\n\x03seq\x18\
    \x03\x20\x02(\x04R\x03seqB\0:\0\"\x89\x01\n\rUpdateRequest\x12\x10\n\x02\
    id\x18\x01\x20\x02(\rR\x02idB\0\x12\x1e\n\tminLength\x18\x02\x20\x01(\
    \x04R\tminLengthB\0\x12(\n\x0bifAvailable\x18\x03\x20\x01(\x08:\x04trueR\
    \x0bifAvailableB\0\x12\x1a\n\x04hash\x18\x04\x20\x01(\x08:\x04trueR\x04h\
    ashB\0:\0\"\xb5\x01\n\x0bSeekRequest\x12\x10\n\x02id\x18\x01\x20\x02(\rR\
    \x02idB\0\x12\x20\n\nbyteOffset\x18\x02\x20\x02(\x04R\nbyteOffsetB\0\x12\
    \x16\n\x05start\x18\x03\x20\x01(\x04R\x05startB\0\x12\x12\n\x03end\x18\
    \x04\x20\x01(\x04R\x03endB\0\x12\x1a\n\x04wait\x18\x05\x20\x01(\x08:\x04\
    trueR\x04waitB\0\x12(\n\x0bifAvailable\x18\x06\x20\x01(\x08:\x04trueR\
    \x0bifAvailableB\0:\0\"H\n\x0cSeekResponse\x12\x12\n\x03seq\x18\x01\x20\
    \x02(\x04R\x03seqB\0\x12\"\n\x0bblockOffset\x18\x02\x20\x02(\x04R\x0bblo\
    ckOffsetB\0:\0\"4\n\nHasRequest\x12\x10\n\x02id\x18\x01\x20\x02(\rR\x02i\
    dB\0\x12\x12\n\x03seq\x18\x02\x20\x02(\x04R\x03seqB\0:\0\"#\n\x0bHasResp\
    onse\x12\x12\n\x03has\x18\x01\x20\x02(\x08R\x03hasB\0:\0\"E\n\rCancelReq\
    uest\x12\x10\n\x02id\x18\x01\x20\x02(\x04R\x02idB\0\x12\x20\n\nresourceI\
    d\x18\x02\x20\x02(\x04R\nresourceIdB\0:\0\"\xbd\x01\n\x0fDownloadRequest\
    \x12\x10\n\x02id\x18\x01\x20\x02(\x04R\x02idB\0\x12\x20\n\nresourceId\
    \x18\x02\x20\x02(\x04R\nresourceIdB\0\x12\x16\n\x05start\x18\x03\x20\x01\
    (\x04R\x05startB\0\x12\x12\n\x03end\x18\x04\x20\x01(\x04R\x03endB\0\x12\
    \x18\n\x06blocks\x18\x05\x20\x03(\x04R\x06blocksB\0\x12\x18\n\x06linear\
    \x18\x06\x20\x01(\x08R\x06linearB\0\x12\x14\n\x04live\x18\x07\x20\x01(\
    \x08R\x04liveB\0:\0\"S\n\x11DownloadedRequest\x12\x10\n\x02id\x18\x01\
    \x20\x02(\x04R\x02idB\0\x12\x16\n\x05start\x18\x02\x20\x01(\x04R\x05star\
    tB\0\x12\x12\n\x03end\x18\x03\x20\x01(\x04R\x03endB\0:\0\".\n\x12Downloa\
    dedResponse\x12\x16\n\x05bytes\x18\x01\x20\x02(\x04R\x05bytesB\0:\0\"I\n\
    \x11UndownloadRequest\x12\x10\n\x02id\x18\x01\x20\x02(\x04R\x02idB\0\x12\
    \x20\n\nresourceId\x18\x02\x20\x02(\x04R\nresourceIdB\0:\0\"!\n\x0bLockR\
    equest\x12\x10\n\x02id\x18\x01\x20\x02(\x04R\x02idB\0:\0\"+\n\x15WatchDo\
    wnloadsRequest\x12\x10\n\x02id\x18\x01\x20\x02(\x04R\x02idB\0:\0\"-\n\
    \x17UnwatchDownloadsRequest\x12\x10\n\x02id\x18\x01\x20\x02(\x04R\x02idB\
    \0:\0\"]\n\x0bAppendEvent\x12\x10\n\x02id\x18\x01\x20\x02(\x04R\x02idB\0\
    \x12\x18\n\x06length\x18\x02\x20\x02(\x04R\x06lengthB\0\x12\x20\n\nbyteL\
    ength\x18\x03\x20\x02(\x04R\nbyteLengthB\0:\0\"G\n\tPeerEvent\x12\x10\n\
    \x02id\x18\x01\x20\x02(\x04R\x02idB\0\x12&\n\x04peer\x18\x02\x20\x02(\
    \x0b2\x10.hyperspace.PeerR\x04peerB\0:\0\"\x20\n\nCloseEvent\x12\x10\n\
    \x02id\x18\x01\x20\x02(\x04R\x02idB\0:\0\"Q\n\tWaitEvent\x12\x10\n\x02id\
    \x18\x01\x20\x02(\x04R\x02idB\0\x12\x1c\n\x08onWaitId\x18\x02\x20\x02(\
    \x04R\x08onWaitIdB\0\x12\x12\n\x03seq\x18\x03\x20\x02(\x04R\x03seqB\0:\0\
    \"7\n\rDownloadEvent\x12\x10\n\x02id\x18\x01\x20\x02(\x04R\x02idB\0\x12\
    \x12\n\x03seq\x18\x02\x20\x02(\x04R\x03seqB\0:\0\"f\n\x18RegisterExtensi\
    onRequest\x12\x10\n\x02id\x18\x01\x20\x02(\x04R\x02idB\0\x12\x20\n\nreso\
    urceId\x18\x02\x20\x02(\x04R\nresourceIdB\0\x12\x14\n\x04name\x18\x03\
    \x20\x02(\tR\x04nameB\0:\0\"R\n\x1aUnregisterExtensionRequest\x12\x10\n\
    \x02id\x18\x01\x20\x02(\x04R\x02idB\0\x12\x20\n\nresourceId\x18\x02\x20\
    \x02(\x04R\nresourceIdB\0:\0\"\x8a\x01\n\x10ExtensionMessage\x12\x10\n\
    \x02id\x18\x01\x20\x02(\x04R\x02idB\0\x12\x20\n\nresourceId\x18\x02\x20\
    \x02(\x04R\nresourceIdB\0\x12*\n\x0fremotePublicKey\x18\x03\x20\x01(\x0c\
    R\x0fremotePublicKeyB\0\x12\x14\n\x04data\x18\x04\x20\x02(\x0cR\x04dataB\
    \0:\0B\0b\x06proto2\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
